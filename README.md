# c_programming
독하게 시작하는 C 프로그래밍(with 최호성)

p.s 본 강의는 VS 2013 버전을 사용하지만 용량이 큰 관계로 VScode에서 gcc컴파일러를 설치해서 실습을 진행하였습니다.

#### [1장 설치 및 코드분석]

HelloWorld.c  =  High level 언어 (사람을 위한) 설계도  
HelloWorld.obj = 기계어 (컴파일러를 통해 번역) 부품
HelloWorld.exe = 최종 (링커를 통해 Link) 완성품

부품을 완성품으로 조립하는 것을 link. 

<코드분석>
```{.c}
#include<stdio.h> //-> 전처리기(Pre Processor)
int main(void)	  //-> 함수 선언 및 정의  매개변수가 없을 땐 void를 넣어주어야 한다
{		// ->  Block Scope

}
```
.c는 정의, .h는 선언.  h안에 정의를 넣을 수 있지만 에러가 나기 때문에 안한다.

여러 항이 모여 구분을 이루고, 구문이 모여 함수를 이루고, 함수가 모여 프로그램을 만든다. 단, main()는 특별해서 얘로 시작해서 얘가 끝나면 프로그램이 끝남

전처리기는 컴파일 전을 의미한다.
caller가 callee를 부를 때는 실인수(매개열)를 기술해줘야 한다.

#### [2장 자료형]

B언어와 C언어를 가른 중요한 개념.  
자료형의 정의 : 일정 길이의 메모리에 저장된 정보의 해석하는 방법.  

32bit-App의 뜻 : 2^32 값 만큼의 bit가 있다. 이걸 2^10으로 단위를 바꾸다 보면 4GB가 된다. win 32bit는 최대 4GB의 메모리밖에 사용할 수 없다. 64bit는 2^64승.  
메모리 주소는 1바이트씩 끊어서 16진수로 적는다. ex) 0x00000001  8비트가 모여 1바이트가 되고 1바이트가 최소 메모리 단위(기록 단위)가 된다.  

변수 : 값이 확정되지 않은 메모리 
상수 : 값이 확정된 메모리

ASCII 코드가 7bit로 영문 대소문자, 숫자까지 다 표현 되는데 특수문자까지 포함하기 위해 8bit로 만들었고 지금 1개의 저장공간인 1byte가 8bit가 된 이유이다.

정수는 부호가 있는 애들과 없는 애들로 구분할 수 있는데 부호가 있는 애들이 나중에 character가 된다.

컴퓨터는 기준위치에서 상대위치와의 차이만큼 이동하게 된다. 

뺄셈은 보수를 구한 다음에 더하면 뺄셈이 된다. 컴퓨터는 이렇게 뺄셈을 함.

부호의 개념이 없으면 unsinged, 있으면 signed라고 표기한다. 이는 부호여부에 따라 데이터의 값이 전혀 달라지기 때문이다.

C99이상부터는 변수를 맨 앞에 몰아서 쓰지 않아도 된다. 이전 버전에는 오류가 났지만 패치되었다. 이제는 선언부 정의부 코드루 등을 구분하지 않는다.

long은 32bit가 되기도, 64bit가 되기도 한다. 따라서 C99에서 longlongint 데이터타입이 등장했다. 얘는 무조건 64bit이고 사용할 때는 %lld로 쓴다.

부동소수점, 혹은 실수는 필연적으로 오차를 발생시킬 수 있다. 그 이유는 근사값처리 떄문.  무한소수의 경우 계속 반복할 수 없기 때문에 근사값으로 출력이 된다. 이 차이가 모여서 큰 오차가 만들어 질 수 있다.

float : 유효소수점 이하 6자리
double :유효소수점 이하 15자리 까지만 데이터가 완전하며 그 이후 자리수부터는 오차가 발생

따라서 소수점을 할 때는 float말고 double형을 사용해야하며 16자리 이상이 될 경우 대책을 간구해야함.

문자열은 사실 문자배열이다. 배열을 사용할 때는 메모리창을 띄어놓고 사용해야한다.(VS에서 가능)  
문자열의 맨 끝은 null문자로 끝난다.

코드도 하나의 문서라고 생각하고 읽는사람을 배려하며 작성해야한다. 프로그래밍은 문화이고 소통, 협업이다. 또한 C언어에서는 헝가리안 표기법을 사용한다.

<메모리에 대한 기본이론>
1. 32비트 플랫폼에서 주소의 길이는 32비트이며 16진수로 표시한다. 그리고 주소의 범위는 0부터 2^32-1번지까지 모두 이어져있는 선형 메모리이다.

2. 자료형은 일정 크기의 메모리를 해석하는 방법이고, 변수는 해석할 대상 메모리에 붙인 이름이다.

3. 특정 영역의 메모리는 운영체제가 사용하고 있다.

4. 스택이든, 힙이든, 실행 코드 영역이든 모두 선형 메모리 위에 일렬로 존재한다.

#### [3장 표준 입출력]

컴퓨터는 H/W 위에 Kernel(OS)가 있고, 그 위에 User mode가 있다. Debugger는 User layer에 있으면 다른 Thread간에 간섭이 가능하다.  
따라서 이놈을 잘 사용하면 좋은 도구가 되지만, 반대로 악의를 갖게 되면 해킹의 도구가 된다.

이번 강의의 핵심은 IO의 주체는 User가 아니라 Kernel이란 것이다. 기본적으로 IO는 Kernel 층에서 관여하며 User는 Kernel층에 관여할 수 없다. 이런 문제를 해결하기 위해 각 층의 교류를 위해 만들어둔 것이 File이다. User층에서 File을 통해 입출력에 관한 내용을 Kernel에 전달하면 Kernel이 그를 기반으로 입출력을 진행한다.  
이런 파일 중에 TCP 프로토콜과 관련된 File을 Socket이라고 부른다.

File은 IO 각각의 buffer를 갖고 있다. buffer를 채우는 것이 버퍼링이고(putchar함수), getchar함수는 버퍼에 있는 한 글자를 퍼 올리는 함수이다. 

buffer가 왜 버퍼인가! 하면 메모리이지만 네트워크가 끊어진 상태(충격)을 완와하기 위해 버퍼에 데이터를 쌓아두고 쌓인 만큼의 시간동안 데이터를 활용하고, 그 시간차 동안 네트워크가 복구되면 연속적인 업무처리와 다르지않은 결과를 낸다. 예를 들면 동영상 실시간 스트리밍 서비스를 생각하면 된다. 한창 보다가 인터넷이 끊겨도 몇초간은 꾸준히 재상이 되는 경험이 바로 그것이다.

C의 IO 함수 중 gets와 몇몇 함수들은 심각한 보안결함이 존재한다. 따라서 gets_s등의 함수를 사용하기를 권고한다. [보안결함](http://andyader.blogspot.kr/2014/03/gets.html)

C 강의를 듣게 되면서 기본이라고 넘겼던 내용들을 다시한번 생각하게 된다. 